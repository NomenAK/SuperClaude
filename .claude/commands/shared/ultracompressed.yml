# UltraCompressed Mode Patterns
# Systematic token reduction & compressed communication patterns

## Legend (Auto-Generated Based on Usage)
| Symbol | Meaning | | Abbrev | Meaning |
|--------|---------|---|--------|---------|
| → | leads to | | cfg | configuration |
| & | and/with | | impl | implementation |
| > | greater than | | ops | operations |
| » | sequence flow | | perf | performance |
| : | define/specify | | req | required |
| ✓ | verified/confirmed | | opt | optional |
| ⚠ | warning/risk | | temp | temporary |
| 🔧 | tool/utility | | std | standard |

## Activation Patterns

```yaml
Activation_Triggers:
  Explicit_Flag:
    Primary: "--uc (UltraCompressed mode)"
    Command_Integration: "All commands support --uc flag"
    Override: "Explicit flag overrides all other triggers"
    
  Natural_Language:
    Keywords: ["compress", "concise", "brief", "minimal", "telegram style", "ultra compressed"]
    Phrases: ["make it shorter", "reduce tokens", "compress output", "telegram format"]
    Context: "User explicitly requests compressed communication"
    
  Automatic_Triggers:
    High_Context_Usage: "Context usage >75% → Auto-activate"
    Token_Budget_Pressure: "Approaching token limits → Auto-activate"
    Large_Codebases: "Project >10k files → Recommend --uc"
    Long_Sessions: "Session >2 hours → Suggest --uc"
    
  Command_Combinations:
    --uc + --think: "Compressed thinking output"
    --uc + --seq: "Compressed sequential analysis"
    --uc + --magic: "Compressed component descriptions"
    --uc + --c7: "Compressed documentation summaries"

Detection_Patterns:
  Context_Analysis:
    File_Count: ">5k files → High complexity"
    Response_Length: "Previous responses >2k tokens → Candidate"
    Session_Duration: ">90 minutes → Token conservation mode"
    
  User_Behavior:
    Repeated_Commands: "Same command >3 times → Suggest --uc"
    Large_Requests: "Multi-part requests → Recommend --uc"
    Time_Pressure: "Keywords: quick, fast, urgent → Auto-suggest --uc"
```

## Token Reduction Strategies

```yaml
Systematic_Compression:
  Remove_Filler_Words:
    Articles: ["the", "a", "an"] → Remove unless critical
    Qualifiers: ["very", "really", "quite", "rather"] → Remove
    Verbal_Padding: ["in order to" → "to", "due to the fact that" → "because"]
    Redundancy: ["and also" → "&", "as well as" → "&"]
    
  Symbol_Substitution:
    Logical_Operators:
      "and" → "&"
      "or" → "|"
      "leads to" → "→"
      "greater than" → ">"
      "less than" → "<"
      "define/specify" → ":"
      "sequence" → "»"
      
  Abbreviation_System:
    Technical_Terms:
      "configuration" → "cfg"
      "implementation" → "impl"
      "operations" → "ops"
      "performance" → "perf"
      "required" → "req"
      "optional" → "opt"
      "temporary" → "temp"
      "standard" → "std"
      "development" → "dev"
      "production" → "prod"
      
  Format_Optimization:
    Lists: "Bullets > prose paragraphs"
    Structure: "YAML > narrative text"
    Headers: "Symbolic prefixes > full sentences"
    Examples: "Code > explanatory text"

Output_Formatting:
  Documentation_Style:
    Headers: "Minimal → Essential info only"
    Sections: "Compressed → Key points only"
    Examples: "Compact → Working code without verbose explanation"
    
  Response_Structure:
    Introduction: "Skip → Direct to content"
    Conclusion: "Skip → End at completion"
    Transitions: "Minimal → Essential flow only"
    
  Code_Documentation:
    Comments: "Essential only → Remove explanatory"
    Variable_Names: "Short but clear → No verbosity"
    Function_Names: "Concise → Core purpose only"
```

## Auto-Legend Generation

```yaml
Legend_Management:
  Symbol_Tracking:
    Usage_Detection: "Scan output for symbols used"
    Frequency_Analysis: "Track symbol frequency in session"
    Auto_Generation: "Generate legend with used symbols only"
    
  Legend_Placement:
    Document_Start: "Legend at beginning of compressed docs"
    Section_Headers: "Mini-legend for section-specific symbols"
    Context_Sensitive: "Show relevant symbols only"
    
  Symbol_Categories:
    Flow_Control: ["→", "»", "&", "|"]
    Status_Indicators: ["✓", "⚠", "🔧", "📝"]
    Relationships: [">", "<", ":", "="]
    Operations: ["🔄", "🔀", "⚡", "🎯"]
    
  Abbreviation_Categories:
    Technical: ["cfg", "impl", "ops", "perf"]
    Status: ["req", "opt", "temp", "std"]
    Context: ["dev", "prod", "test", "doc"]
    Domain: ["UI", "API", "DB", "CLI"]

Dynamic_Adaptation:
  Context_Awareness:
    First_Use: "Full term w/ abbreviation introduction"
    Subsequent: "Abbreviation only after definition"
    Technical_Context: "Higher abbreviation density allowed"
    User_Familiarity: "Adapt to user's technical level"
    
  Clarity_Preservation:
    Critical_Information: "Never compress safety-critical details"
    Error_Messages: "Maintain clarity for debugging"
    Instructions: "Preserve step clarity for complex operations"
    Code_Logic: "Keep code readable despite compression"
```

## Integration Patterns

```yaml
Command_Integration:
  Flag_Support:
    All_Commands: "Support --uc flag universally"
    Help_Text: "Include --uc in flag documentation"
    Validation: "Validate --uc compatibility with other flags"
    
  Output_Adaptation:
    Analysis_Commands: "Compress findings → Key insights only"
    Build_Commands: "Compress logs → Essential status only"
    Documentation_Commands: "Compress docs → Core facts only"
    
  Error_Handling:
    Compressed_Errors: "Essential error info only"
    Debug_Information: "Minimal debug output"
    Recovery_Instructions: "Concise fix guidance"

Persona_Integration:
  Architect: "Compressed system diagrams & decisions"
  Frontend: "Compressed component specs & patterns"
  Backend: "Compressed API docs & data flows"
  Analyzer: "Compressed findings & evidence"
  Security: "Compressed threat assessments"
  
MCP_Integration:
  Context7: "Compressed documentation summaries"
  Sequential: "Compressed thinking steps"
  Magic: "Compressed component descriptions"
  Puppeteer: "Compressed test results"

Session_Management:
  State_Tracking:
    Compression_Level: "Track user preference for compression depth"
    Symbol_Usage: "Track symbols used in session"
    Effectiveness: "Monitor token savings achieved"
    
  Progressive_Compression:
    Session_Start: "Standard compression level"
    High_Usage: "Increase compression automatically"
    User_Feedback: "Adjust based on user responses"
    
  Quality_Control:
    Clarity_Metrics: "Ensure comprehensibility maintained"
    Information_Preservation: "Critical details not lost"
    User_Satisfaction: "Monitor for compression complaints"
```

## Quality Assurance

```yaml
Compression_Validation:
  Information_Integrity:
    Essential_Facts: "Never compress critical information"
    Accuracy_Check: "Verify compressed output maintains accuracy"
    Completeness: "Ensure no essential details lost"
    
  Readability_Standards:
    Technical_Accuracy: "Maintain technical precision"
    Logical_Flow: "Preserve logical progression"
    Context_Clarity: "Ensure context remains clear"
    
  User_Experience:
    Learning_Curve: "Minimize cognitive load from symbols"
    Consistency: "Use symbols consistently throughout"
    Progressive_Disclosure: "Introduce complexity gradually"

Fallback_Mechanisms:
  Clarity_Issues:
    User_Confusion: "Expand explanation if user indicates confusion"
    Critical_Operations: "Full detail for safety-critical operations"
    First_Time_Users: "Less aggressive compression initially"
    
  Technical_Complexity:
    High_Complexity: "Reduce compression for complex technical topics"
    Debugging_Context: "Full detail for troubleshooting"
    Learning_Context: "Balance compression with educational value"
```

## Performance Metrics

```yaml
Token_Efficiency:
  Measurement:
    Baseline: "Standard output token count"
    Compressed: "UltraCompressed output token count"
    Savings: "Calculate percentage reduction"
    
  Targets:
    Documentation: "30-50% token reduction"
    Responses: "20-40% token reduction"
    Code_Comments: "40-60% token reduction"
    
  Monitoring:
    Session_Tracking: "Track cumulative savings"
    Command_Analysis: "Per-command efficiency metrics"
    User_Satisfaction: "Balance efficiency with usability"

Quality_Metrics:
  Comprehension:
    User_Questions: "Track clarification requests"
    Task_Completion: "Monitor successful outcomes"
    Error_Rates: "Track mistakes from compression"
    
  Effectiveness:
    Time_Savings: "Measure reduced reading time"
    Cognitive_Load: "Assess user mental effort"
    Information_Density: "Measure info per token"
```

---
*UltraCompressed Mode v4.0.0 - Systematic token reduction patterns for efficient communication*